#!/usr/bin/python
# d_wrapper_gen.py

import re

header_text = """// {0}
// ***************************************************************
// This file has been automatically generated by d_wrapper_gen.py
// Please do not modify it by hand !
// ***************************************************************

extern(C):

"""

filenames_in = ['Horde3D.h', 'Horde3DUtils.h']

for filename in filenames_in:
	# Open the original .h :
	try:
		f_in = open(filename, 'r')
	except IOError:
		print 'Could not open ' + filename + ' for reading !'
		continue

	# Open the generated .d :
	d_filename = filename[0:-2] + '.d'
	try:
		f_out = open(d_filename, 'w')
	except IOError:
		print 'Could not open ' + d_filename + ' for writing !'
		f_in.close()
		continue

	# Compile some regexes :
	struct_regex = re.compile(r"^struct\s.*$")
	enum_regex = re.compile(r"^\senum\s.*$")
	end_block_regex = re.compile(r"^};$")
	enum_identifier_regex = re.compile(r"^\s*[a-zA-Z0-9_]+.*$")
	start_comment_regex = re.compile(r"^.*\/\*.*$")
	end_comment_regex = re.compile(r"^.*\*\/.*$")

	# Generate the .d file :
	print 'Generating ' + f_out.name + '...'
	f_out.write(header_text.format(f_out.name))

	if filename.startswith('Horde3DUtils'):
		f_out.write('import Horde3D;\n');

	for l in f_in:
		# Skip the preprocessor directives :
		if l.strip().startswith('#'):
			continue

		# Replacements :
		l = l.replace('DLL ', '')
		l = l.replace('typedef', 'alias')
		l = l.replace('const', '')
		l = l.replace('::List', '')
		l = l.replace('unsigned char', 'ubyte')
		l = l.replace('H3DNode H3DRootNode', 'const H3DNode H3DRootNode')


		# If it is the start of a struct :
		if struct_regex.match(l):
			#print 'START STRUCT : ' + l[0:-1]
			struct_name = l.split()[1]

			# Treat the struct :
			for l in f_in:
				# Skip the C-style comments :
				if start_comment_regex.match(l):
					#print 'START COMMENT : ' + l[0:-1]
					f_out.write(l)

					for l in f_in:	# loop until the end of the comment
						f_out.write(l)
						if end_comment_regex.match(l):
							break

					#print 'END COMMENT : ' + l[0:-1]

				# Treat the enum(s) :
				if enum_regex.match(l):
					#print '  START ENUM : ' + l[0:-1]
					f_out.write('enum ' + struct_name + '\n{\n')

					for l in f_in:
						if end_block_regex.match(l):
							#print '  END ENUM : ' + l[0:-1]
							f_out.write('}\n')
							break

						if enum_identifier_regex.match(l):
							#print '    IDENTIFIER : ' + l[0:-1]
							f_out.write('\t' + l.strip() + '\n')

				# Check the end of the struct :
				if end_block_regex.match(l):
					#print 'END STRUCT : ' + l[0:-1]
					break

		else:	# l is not in a struct :
			f_out.write(l)

	# Close all files
	f_in.close()
	f_out.close()
