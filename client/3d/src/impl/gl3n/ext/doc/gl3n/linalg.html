<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>gl3n.linalg</title>
        </head><body>
        <h1>gl3n.linalg</h1>
        <!-- Generated by Ddoc from gl3n/linalg.d -->
gl3n.<u>linalg</u>
<br><br>
Special thanks to:
<ul> <li>Tomasz Stachowiak (h3r3tic): allowed me to use parts of <a href="https://bitbucket.org/h3r3tic/boxen/src/default/src/xf/omg">omg</a>.</li>
  <li>Jakob Ã˜vrum (jA_cOp): improved the code a lot!</li>
  <li>Florian Boesch (__doc__): helps me to understand opengl/complex maths better, see: <a href="http://codeflow.org/">http://codeflow.org/</a>.</li>
  <li>#D on freenode: answered general questions about D.</li>
</ul>

<br><br>
<b>Authors:</b><br>
David Herberth
<br><br>
<b>License:</b><br>
MIT<br><br>

<dl><dt><big>struct <u>Vector</u>(type,int dimension_) if (dimension_ &gt;= 2 &amp;&amp; dimension_ &lt;= 4);
</big></dt>
<dd>Base template for all vector-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
<tr><td>dimension</td>
<td>specifies the dimension of the vector, can be 1, 2, 3 or 4</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>alias</font> <u>Vector</u>!(<font color=blue>int</font>, 3) vec3i;
 <font color=blue>alias</font> <u>Vector</u>!(<font color=blue>float</font>, 4) vec4;
 <font color=blue>alias</font> <u>Vector</u>!(<font color=blue>real</font>, 2) vec2r;
</pre>
<br><br>

<dl><dt><big>alias <u>vt</u>;
</big></dt>
<dd>Holds the internal type of the vector.<br><br>

</dd>
<dt><big>int <u>dimension</u>;
</big></dt>
<dd>Holds the <u>dimension</u> of the vector.<br><br>

</dd>
<dt><big>vt[dimension] <u>vector</u>;
</big></dt>
<dd>Holds all coordinates, length conforms dimension.<br><br>

</dd>
<dt><big>@property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns a pointer to the coordinates.<br><br>

</dd>
<dt><big>alias <u>x</u>;
<br>alias <u>y</u>;
<br>alias <u>s</u>;
<br>alias <u>t</u>;
<br>alias <u>r</u>;
<br>alias <u>g</u>;
<br>alias <u>z</u>;
<br>alias <u>b</u>;
<br>alias <u>p</u>;
<br>alias <u>w</u>;
<br>alias <u>a</u>;
<br>alias <u>q</u>;
</big></dt>
<dd>static properties to access the values.<br><br>

</dd>
<dt><big>this(Args...)(Args <i>args</i>);
<br>this(T)(T <i>vec</i>);
<br>this()(vt <i>value</i>);
</big></dt>
<dd>Constructs the vector.
 If a single value is passed the vector, the vector will be cleared with this value.
 If a vector with a higher dimension is passed the vector will hold the first values up to its dimension.
 If mixed types are passed they will be joined together (allowed types: vector, static array, <i>vt</i>).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> vec4 v4 = vec4(1.0f, vec2(2.0f, 3.0f), 4.0f);
 vec3 v3 = vec3(v4); <font color=green>// v3 = vec3(1.0f, 2.0f, 3.0f);
</font> vec2 v2 = v3.xy; <font color=green>// swizzling returns a static array.
</font> vec3 v3_2 = vec3(1.0f); <font color=green>// vec3 v3_2 = vec3(1.0f, 1.0f, 1.0f);
</font></pre>
<br><br>

</dd>
<dt><big>bool <u>ok</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big>void <u>clear</u>(vt <i>value</i>);
</big></dt>
<dd>Sets all values of the vector to <i>value</i>.<br><br>

</dd>
<dt><big>void <u>update</u>(Vector!(vt,dimension) <i>other</i>);
</big></dt>
<dd>Updates the vector with the values from <i>other</i>.<br><br>

</dd>
<dt><big>string <u>as_string</u>();
<br>alias <u>toString</u>;
</big></dt>
<dd>Returns the current vector formatted as string, useful for printing the vector.<br><br>

</dd>
<dt><big>vt[s.length] <u>opDispatch</u>(string s)();
</big></dt>
<dd>Implements dynamic swizzling.
<br><br>
<b>Returns:</b><br>
a static array of coordinates.<br><br>

</dd>
<dt><big>real <u>magnitude_squared</u>();
</big></dt>
<dd>Returns the squared magnitude of the vector.<br><br>

</dd>
<dt><big>real <u>magnitude</u>();
<br>alias <u>length_squared</u>;
<br>alias <u>length</u>;
</big></dt>
<dd>Returns the <u>magnitude</u> of the vector.<br><br>

</dd>
<dt><big>void <u>normalize</u>();
</big></dt>
<dd>Normalizes the vector.<br><br>

</dd>
<dt><big>Vector <u>normalized</u>();
</big></dt>
<dd>Returns a <u>normalized</u> copy of the current vector.<br><br>

</dd>
</dl>
</dd>
<dt><big>T.vt <u>dot</u>(T)(T <i>veca</i>, T <i>vecb</i>);
</big></dt>
<dd>Calculates the <u>dot</u> product between two vectors.<br><br>

</dd>
<dt><big>T <u>cross</u>(T)(T <i>veca</i>, T <i>vecb</i>);
</big></dt>
<dd>Calculates the <u>cross</u> product of two 3-dimensional vectors.<br><br>

</dd>
<dt><big>T.vt <u>distance</u>(T)(T <i>veca</i>, T <i>vecb</i>);
</big></dt>
<dd>Calculates the <u>distance</u> between two vectors.<br><br>

</dd>
<dt><big>alias <u>vec2</u>;
<br>alias <u>vec3</u>;
<br>alias <u>vec4</u>;
<br>alias <u>vec2d</u>;
<br>alias <u>vec3d</u>;
<br>alias <u>vec4d</u>;
<br>alias <u>vec2i</u>;
<br>alias <u>vec3i</u>;
<br>alias <u>vec4i</u>;
</big></dt>
<dd>Pre-defined vector types, the number represents the dimension and the last letter the type (none = float, d = double, i = int).<br><br>

</dd>
<dt><big>struct <u>Matrix</u>(type,int rows_,int cols_) if (rows_ &gt; 0 &amp;&amp; cols_ &gt; 0);
</big></dt>
<dd>Base template for all matrix-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
<tr><td>rows_</td>
<td>rows of the matrix</td></tr>
<tr><td>cols_</td>
<td>columns of the matrix</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>float</font>, 4, 4) mat4;
 <font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>double</font>, 3, 4) mat34d;
 <font color=blue>alias</font> <u>Matrix</u>!(<font color=blue>real</font>, 2, 2) mat2r;
</pre>
<br><br>

<dl><dt><big>alias <u>mt</u>;
</big></dt>
<dd>Holds the internal type of the matrix;<br><br>

</dd>
<dt><big>int <u>rows</u>;
</big></dt>
<dd>Holds the number of <u>rows</u>;<br><br>

</dd>
<dt><big>int <u>cols</u>;
</big></dt>
<dd>Holds the number of columns;<br><br>

</dd>
<dt><big>mt[cols][rows] <u>matrix</u>;
</big></dt>
<dd>Holds the <u>matrix</u> <font color=red>row-major</font> in memory.<br><br>

</dd>
<dt><big>@property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns the pointer to the stored values as OpenGL requires it.
 Note this will return a pointer to a <font color=red>row-major</font> matrix, 
 this means you've to set the transpose argument to GL_TRUE when passing it to OpenGL.<br><br>

</dd>
<dt><big>this(Args...)(Args <i>args</i>);
<br>this(T)(T <i>mat</i>);
<br>this(T)(T <i>mat</i>);
<br>this()(mt <i>value</i>);
</big></dt>
<dd>Constructs the matrix:
 If a single value is passed, the matrix will be cleared with this value (each column in each row will contain this value).
 If a matrix with more rows and columns is passed, the matrix will be the upper left nxm matrix.
 If a matrix with less rows and columns is passed, the passed matrix will be stored in the upper left of an identity matrix.
 It's also allowed to pass vectors and scalars at a time, but the vectors dimension must match the number of columns and align correctly.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> mat2 m2 = mat2(0.0f); <font color=green>// mat2 m2 = mat2(0.0f, 0.0f, 0.0f, 0.0f);
</font> mat3 m3 = mat3(m2); <font color=green>// mat3 m3 = mat3(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f);
</font> mat3 m3_2 = mat3(vec3(1.0f, 2.0f, 3.0f,), 4.0f, 5.0f, 6.0f, vec3(7.0f, 8.0f, 9.0f));
 mat4 m4 = mat4.identity <font color=green>// just an identity matrix
</font> mat3 m3_3 = mat3(m4) <font color=green>// mat3 m3_3 = mat3.identity
</font></pre>
<br><br>

</dd>
<dt><big>bool <u>ok</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big>void <u>clear</u>(mt <i>value</i>);
</big></dt>
<dd>Sets all values of the matrix to <i>value</i> (each column in each row will contain this <i>value</i>).<br><br>

</dd>
<dt><big>string <u>as_string</u>();
<br>alias <u>toString</u>;
</big></dt>
<dd>Returns the current matrix formatted as flat string.<br><br>

</dd>
<dt><big>string <u>as_pretty_string</u>();
<br>alias <u>toPrettyString</u>;
</big></dt>
<dd>Returns the current matrix as pretty formatted string. <br><br>

</dd>
<dt><big>void <u>make_identity</u>();
</big></dt>
<dd>Makes the current matrix an identity matrix.<br><br>

</dd>
<dt><big>Matrix <u>identity</u>();
</big></dt>
<dd>Returns a <u>identity</u> matrix.<br><br>

</dd>
<dt><big>void <u>transpose</u>();
</big></dt>
<dd>Transposes the current matrix;<br><br>

</dd>
<dt><big>Matrix <u>transposed</u>();
</big></dt>
<dd>Returns a <u>transposed</u> copy of the matrix.<br><br>

</dd>
<dt><big>Matrix <u>xrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the x-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix <u>yrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the y-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix <u>zrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns an identity matrix with an applied rotation around the z-axis (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix <u>rotatex</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the x-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix <u>rotatey</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the y-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix <u>rotatez</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current matrix around the z-axis and returns <i>this</i> (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>void <u>translation</u>(mt[] <i>values</i>...);
</big></dt>
<dd>Sets the <u>translation</u> of the matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>void <u>translation</u>(Matrix <i>mat</i>);
</big></dt>
<dd>Copyies the <u>translation</u> from <i>mat</i> to the current matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix <u>translation</u>();
</big></dt>
<dd>Returns an identity matrix with the current <u>translation</u> applied (nxn matrices, n &gt;= 3)..<br><br>

</dd>
<dt><big>void <u>scale</u>(mt[] <i>values</i>...);
</big></dt>
<dd>Sets the <u>scale</u> of the matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>void <u>scale</u>(Matrix <i>mat</i>);
</big></dt>
<dd>Copyies the <u>scale</u> from <i>mat</i> to the current matrix (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix <u>scale</u>();
</big></dt>
<dd>Returns an identity matrix with the current <u>scale</u> applied (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>void <u>rotation</u>(Matrix!(mt,3,3) <i>rot</i>);
</big></dt>
<dd>Copies <i>rot</i> into the upper left corner, the translation (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix!(mt,3,3) <u>rotation</u>();
</big></dt>
<dd>Returns an identity matrix with the current <u>rotation</u> applied (nxn matrices, n &gt;= 3).<br><br>

</dd>
<dt><big>Matrix <u>inverse</u>();
</big></dt>
<dd>Returns an inverted copy of the current matrix (nxn matrices, n &lt;= 4).<br><br>

</dd>
<dt><big>void <u>invert</u>();
</big></dt>
<dd>Inverts the current matrix (nxn matrices, n &lt;= 4).<br><br>

</dd>
</dl>
</dd>
<dt><big>alias <u>mat2</u>;
</big></dt>
<dd>Pre-defined matrix types, the first number represents the number of rows 
 and the second the number of columns, if there's just one it's a nxn matrix.
 All of these matrices are floating-point matrices.<br><br>

</dd>
<dt><big>struct <u>Quaternion</u>(type);
</big></dt>
<dd>Base template for all quaternion-types.
<br><br>
<b>Params:</b><br>
<table><tr><td>type</td>
<td>all values get stored as this type</td></tr>
</table><br>

<dl><dt><big>alias <u>qt</u>;
</big></dt>
<dd>Holds the internal type of the quaternion.<br><br>

</dd>
<dt><big>qt[4] <u>quaternion</u>;
</big></dt>
<dd>Holds the w, x, y and z coordinates.<br><br>

</dd>
<dt><big>@property auto <u>value_ptr</u>();
</big></dt>
<dd>Returns a pointer to the quaternion in memory, it starts with the w coordinate.<br><br>

</dd>
<dt><big>alias <u>w</u>;
<br>alias <u>x</u>;
<br>alias <u>y</u>;
<br>alias <u>z</u>;
</big></dt>
<dd>static properties to access the values.<br><br>

</dd>
<dt><big>this(qt <i>w_</i>, qt <i>x_</i>, qt <i>y_</i>, qt <i>z_</i>);
<br>this(qt <i>w_</i>, Vector!(qt,3) <i>vec</i>);
<br>this(Vector!(qt,4) <i>vec</i>);
</big></dt>
<dd>Constructs the quaternion.
 Takes a 4-dimensional vector, where vector.x = the quaternions w coordinate,
 or a w coordinate of type <i>qt</i> and a 3-dimensional vector representing the imaginary part,
 or 4 values of type <i>qt</i>.<br><br>

</dd>
<dt><big>bool <u>ok</u>();
</big></dt>
<dd>Returns <b>true</b> if all values are not nan and finite, otherwise <b>false</b>.<br><br>

</dd>
<dt><big>real <u>magnitude_squared</u>();
</big></dt>
<dd>Returns the squared magnitude of the quaternion.<br><br>

</dd>
<dt><big>real <u>magnitude</u>();
</big></dt>
<dd>Returns the <u>magnitude</u> of the quaternion.<br><br>

</dd>
<dt><big>Quaternion <u>identity</u>();
</big></dt>
<dd>Returns an <u>identity</u> quaternion (w=1, x=0, y=0, z=0).<br><br>

</dd>
<dt><big>void <u>make_identity</u>();
</big></dt>
<dd>Makes the current quaternion an identity quaternion.<br><br>

</dd>
<dt><big>void <u>invert</u>();
<br>alias <u>conjugate</u>;
</big></dt>
<dd>Inverts the quaternion.<br><br>

</dd>
<dt><big>Quaternion <u>inverse</u>();
<br>alias <u>conjugated</u>;
</big></dt>
<dd>Returns an inverted copy of the current quaternion.<br><br>

</dd>
<dt><big>string <u>as_string</u>();
</big></dt>
<dd>Returns the current vector formatted as string, useful for printing the quaternion.<br><br>

</dd>
<dt><big>Quaternion <u>from_matrix</u>(Matrix!(qt,3,3) <i>matrix</i>);
</big></dt>
<dd>Creates a quaternion from a 3x3 <i>matrix</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>Matrix!(qt,3,3) <i>matrix</i></td>
<td>3x3 <i>matrix</i> (rotation)</td></tr>
</table><br>
<b>Returns:</b><br>
A quaternion representing the rotation (3x3 <i>matrix</i>)<br><br>

</dd>
<dt><big>Matrix!(qt,rows,cols) <u>to_matrix</u>(int rows, int cols)();
</big></dt>
<dd>Returns the quaternion as matrix.
<br><br>
<b>Params:</b><br>
<table><tr><td>rows</td>
<td>number of rows of the resulting matrix (min 3)</td></tr>
<tr><td>cols</td>
<td>number of columns of the resulting matrix (min 3)</td></tr>
</table><br>

</dd>
<dt><big>void <u>normalize</u>();
</big></dt>
<dd>Normalizes the current quaternion.<br><br>

</dd>
<dt><big>Quaternion <u>normalized</u>();
</big></dt>
<dd>Returns a <u>normalized</u> copy of the current quaternion.<br><br>

</dd>
<dt><big>real <u>yaw</u>();
</big></dt>
<dd>Returns the <u>yaw</u>.<br><br>

</dd>
<dt><big>real <u>pitch</u>();
</big></dt>
<dd>Returns the <u>pitch</u>.<br><br>

</dd>
<dt><big>real <u>roll</u>();
</big></dt>
<dd>Returns the <u>roll</u>.<br><br>

</dd>
<dt><big>Quaternion <u>xrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the x-axis.<br><br>

</dd>
<dt><big>Quaternion <u>yrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the y-axis.<br><br>

</dd>
<dt><big>Quaternion <u>zrotation</u>(real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around the z-axis.<br><br>

</dd>
<dt><big>Quaternion <u>axis_rotation</u>(Vector!(qt,3) <i>axis</i>, real <i>alpha</i>);
</big></dt>
<dd>Returns a quaternion with applied rotation around an <i>axis</i>.<br><br>

</dd>
<dt><big>Quaternion <u>euler_rotation</u>(real <i>heading</i>, real <i>attitude</i>, real <i>bank</i>);
</big></dt>
<dd>Creates a quaternion from an euler rotation.<br><br>

</dd>
<dt><big>Quaternion <u>rotatex</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the x-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big>Quaternion <u>rotatey</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the y-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big>Quaternion <u>rotatez</u>(real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around the z-axis and returns <i>this</i>.<br><br>

</dd>
<dt><big>Quaternion <u>rotate_axis</u>(Vector!(qt,3) <i>axis</i>, real <i>alpha</i>);
</big></dt>
<dd>Rotates the current quaternion around an <i>axis</i> and returns <i>this</i>.<br><br>

</dd>
<dt><big>Quaternion <u>rotate_euler</u>(real <i>heading</i>, real <i>attitude</i>, real <i>bank</i>);
</big></dt>
<dd>Applies an euler rotation to the current quaternion and returns <i>this</i>.<br><br>

</dd>
</dl>
</dd>
<dt><big>alias <u>quat</u>;
</big></dt>
<dd>Pre-defined quaternion of type float.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
