<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
	<html>
		<head>
			<meta http-equiv="content-type" content="text/html; charset=utf-8">
			<title>index - gl3n's documentation</title>
			<link rel="stylesheet" type="text/css" href="./style.css">
			<script type="text/javascript" src="./jquery.js"></script>
			<script type="text/javascript" src="./cutedoc.js"></script>
		</head>
		<body>
			<div id="header">
				<div id="inner">
					<big>index</big> - <small>gl3n's documentation</small>
				</div>
			</div>
			
			<div id="floating">
				<div id="modulesouter">
					<h3>Modules</h3>
					<div id="modules"><li><a href="./linalg.html" title="linear algebra">linalg</a></li><li><a href="./math.html" title="mathematical functions">math</a></li><li><a href="./interpolate.html" title="interpolation">interpolate</a></li><li><a href="./util.html" title="useful utilities">util</a></li></div>
				</div>
				
				<div id="childsouter">
					<h3>Jump to</h3>
					<div id="childs"></div>		
				</div>
			</div>
			
			<div id="content">
				<!-- Generated by Ddoc from index.d -->


<a href="https://bitbucket.org/dav1d/gl3n/overview">gl3n</a> provides all the math you need to work with OpenGL, DirectX.
Currently gl3n supports:
<ul> <li>linear algebra</li>
  <ul>   <li>vectors</li>
    <li>matrices</li>
    <li>quaternions</li>
  </ul>
  <li>interpolation</li>
  <ul>   <li>linear interpolation (lerp)</li>
    <li>spherical linear interpolation (slerp)</li>
    <li>hermite interpolation</li>
    <li>catmull rom interpolation</li>
  </ul>
  <li>nearly all GLSL defined functions (according to spec 4.1)</li>
  <li>the power of D, e.g. dynamic swizzling, templated types (vectors, matrices, quaternions), impressive constructors and more!</li>
</ul>
<br />
Furthermore <a href="https://bitbucket.org/dav1d/gl3n/overview">gl3n</a> is MIT licensed,
which allows you to use it everywhere you want it.
<br /><br />
A little example of gl3n's power:
<pre class="d_code">vec4 v4 = vec4(1.0f, vec3(2.0f, 3.0f, 4.0f)); 
vec4 v4_2 = vec4(1.0f, vec4(1.0f, 2.0f, 3.0f, 4.0f).xyz); <span class="code_comment">// "dynamic" swizzling with opDispatch
</span>
vec3 v3 = my_3dvec.rgb; 
<span style="color:blue;">float</span>[] foo = v4.xyzzzwzyyxw <span class="code_comment">// not useful but possible!
</span>
mat4 m4fv = mat4.translation(-0.5f, -0.54f, 0.42f).rotatex(PI).rotatez(PI/2);
glUniformMatrix4fv(location, 1, GL_TRUE, m4fv.value_ptr); <span class="code_comment">// yes they are row major! 
</span>
mat3 inv_view = view.rotation; 
mat3 inv_view = mat3(view); 

mat4 m4 = mat4(vec4(1.0f, 2.0f, 3.0f, 4.0f), 5.0f, 6.0f, 7.0f, 8.0f, vec4(…) …); 
</pre>

<pre class="d_code"><span style="color:blue;">struct</span> Camera { 
    vec3 position = vec3(0.0f, 0.0f, 0.0f); 
    quat orientation = quat.identity; 
    
    Camera rotatex(<span style="color:blue;">real</span> alpha) { orientation.rotatex(alpha); <span style="color:blue;">return</span> <span style="color:blue;">this</span>; } 
    Camera rotatey(<span style="color:blue;">real</span> alpha) { orientation.rotatey(alpha); <span style="color:blue;">return</span> <span style="color:blue;">this</span>; } 
    Camera rotatez(<span style="color:blue;">real</span> alpha) { orientation.rotatez(alpha); <span style="color:blue;">return</span> <span style="color:blue;">this</span>; } 
    
    Camera move(<span style="color:blue;">float</span> x, <span style="color:blue;">float</span> y, <span style="color:blue;">float</span> z) { 
        position += vec3(x, y, z); 
        <span style="color:blue;">return</span> <span style="color:blue;">this</span>; 
    } 
    Camera move(vec3 s) { 
        position += s; 
        <span style="color:blue;">return</span> <span style="color:blue;">this</span>; 
    } 
    
    @property camera() { 
        <span class="code_comment">//writefln("yaw: %s, pitch: %s, roll: %s", degrees(orientation.yaw), degrees(orientation.pitch), degrees(orientation.roll)); 
</span>        <span style="color:blue;">return</span> mat4.translation(position.x, position.y, position.z) * orientation.to_matrix!(4,4); 
    } 
} 

        glUniformMatrix4fv(programs.main.view, 1, GL_TRUE, cam.camera.value_ptr); 
        glUniformMatrix3fv(programs.main.inv_rot, 1, GL_TRUE, cam.orientation.to_matrix!(3,3).inverse.value_ptr);
</pre>

			</div>
			<p align="center"><small>Copyright by  2011.<br/>
			Generated by ddoc, Theme: <a href="https://github.com/robik/cuteDoc">cutedoc</a>.</small></p>
		</body>
	</html>
