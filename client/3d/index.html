<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>index</title>
        </head><body>
        <h1>index</h1>
        <!-- Generated by Ddoc from src\impl\gl3n\ext\index.d -->


<a href="https://bitbucket.org/dav1d/gl3n/overview">gl3n</a> provides all the math you need to work with OpenGL, DirectX.
Currently gl3n supports:
<ul> <li>linear algebra</li>
  <ul>   <li>vectors</li>
    <li>matrices</li>
    <li>quaternions</li>
  </ul>
  <li>interpolation</li>
  <ul>   <li>linear interpolation (lerp)</li>
    <li>spherical linear interpolation (slerp)</li>
    <li>hermite interpolation</li>
    <li>catmull rom interpolation</li>
  </ul>
  <li>nearly all GLSL defined functions (according to spec 4.1)</li>
  <li>the power of D, e.g. dynamic swizzling, templated types (vectors, matrices, quaternions), impressive constructors and more!</li>
</ul>
<br>
Furthermore <a href="https://bitbucket.org/dav1d/gl3n/overview">gl3n</a> is MIT licensed,
which allows you to use it everywhere you want it.
<br><br>
A little example of gl3n's power:
<pre class="d_code">vec4 v4 = vec4(1.0f, vec3(2.0f, 3.0f, 4.0f)); 
vec4 v4_2 = vec4(1.0f, vec4(1.0f, 2.0f, 3.0f, 4.0f).xyz); <font color=green>// "dynamic" swizzling with opDispatch
</font>
vec3 v3 = my_3dvec.rgb; 
<font color=blue>float</font>[] foo = v4.xyzzzwzyyxw <font color=green>// not useful but possible!
</font>
mat4 m4fv = mat4.translation(-0.5f, -0.54f, 0.42f).rotatex(PI).rotatez(PI/2);
glUniformMatrix4fv(location, 1, GL_TRUE, m4fv.value_ptr); <font color=green>// yes they are row major! 
</font>
mat3 inv_view = view.rotation; 
mat3 inv_view = mat3(view); 

mat4 m4 = mat4(vec4(1.0f, 2.0f, 3.0f, 4.0f), 5.0f, 6.0f, 7.0f, 8.0f, vec4(…) …); 
</pre>

<pre class="d_code"><font color=blue>struct</font> Camera { 
    vec3 position = vec3(0.0f, 0.0f, 0.0f); 
    quat orientation = quat.identity; 
    
    Camera rotatex(<font color=blue>real</font> alpha) { orientation.rotatex(alpha); <font color=blue>return</font> <font color=blue>this</font>; } 
    Camera rotatey(<font color=blue>real</font> alpha) { orientation.rotatey(alpha); <font color=blue>return</font> <font color=blue>this</font>; } 
    Camera rotatez(<font color=blue>real</font> alpha) { orientation.rotatez(alpha); <font color=blue>return</font> <font color=blue>this</font>; } 
    
    Camera move(<font color=blue>float</font> x, <font color=blue>float</font> y, <font color=blue>float</font> z) { 
        position += vec3(x, y, z); 
        <font color=blue>return</font> <font color=blue>this</font>; 
    } 
    Camera move(vec3 s) { 
        position += s; 
        <font color=blue>return</font> <font color=blue>this</font>; 
    } 
    
    @property camera() { 
        <font color=green>//writefln("yaw: %s, pitch: %s, roll: %s", degrees(orientation.yaw), degrees(orientation.pitch), degrees(orientation.roll)); 
</font>        <font color=blue>return</font> mat4.translation(position.x, position.y, position.z) * orientation.to_matrix!(4,4); 
    } 
} 

        glUniformMatrix4fv(programs.main.view, 1, GL_TRUE, cam.camera.value_ptr); 
        glUniformMatrix3fv(programs.main.inv_rot, 1, GL_TRUE, cam.orientation.to_matrix!(3,3).inverse.value_ptr);
</pre>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
